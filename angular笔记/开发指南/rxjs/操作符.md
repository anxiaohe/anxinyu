## 操作符

对`Observable`返回的数据包装或限制，返回一个新的`Observable`

#### pipe

用于接受多个操作符作为参数，按照传入顺序处理源`Observable`返回的数据，做否返回一个新的`Observable`。

```
import { from } from 'rxjs';
import { map, filter } from 'rxjs/operators';
from([1, 2, 3, 5, 8, 9, 5, 8, 96, 59, 5496, 465, 84]).pipe(
      filter((val) => val % 2 > 0),
      map((val) => val * 1.5)
).subscribe(val => console.log(val));
```

#### 过滤操作符

- **filter**

  用于对`Observable`返回的数据做过滤。

- **debounce/debounceTime**

  过滤掉两次输出时间小于指定时间的数据。

  ```
  // 用法
  const btn = document.querySelector('button');
  fromEvent<MouseEvent>(btn, 'click')
  .pipe(
  	// debounce(() => interval(500))
  	debounce(() => timer(500))
  ) 
  .subscribe((event) => {
  	// 只输出点击事件的最后一项
  	console.log(event.x);
  });
  
  fromEvent<MouseEvent>(btn, 'click')
  .pipe(
  	debounceTime(500)
  ) 
  .subscribe((event) => {
  	// 只输出点击事件的最后一项
  	console.log(event.x);
  });
  ```

- **distinct/distinctUntilChanged/distinctUntilKeyChanged**

  distinct：去重

  distinctUntilChanged/distinctUntilKeyChanged：比较当前项和前一项的区别，不同则返回当前项

  ```
  interface List {
    name: string;
    age: number;
  }
  export const list: List[] = [
    { name: 'a', age: 12, },
    { name: 'b', age: 13, },
    { name: 'c', age: 56, },
    { name: 'a', age: 12, },
    { name: 'b', age: 59, },
    { name: 'c', age: 43, },
  ];
  from(list).pipe(
  	distinct(val => val.name)
  )
  .subscribe(val => console.log(val))
  
  from([1,2,5,8,3,5,41,41,1,1,2,3])
  .pipe(
  	distinct()
  )
  .subscribe(val => conosle.log(val))
  
  from(list).pipe(
  	distinctUntilChanged((previous, current) => {
  		// 如果返回值为true,则不返回当前项，第一项不做比较
  		return current.age === 12
  	})
  )
  .subscribe(val => console.log(val))
  
  // distinctUntilKeyChanged是默认传入一个属性，不是去重，是比较当前项是否与前一项相同，相同则不输出当前项
  from(list).pipe(
  	distinctUntilKeyChanged('name')
  )
  可在传入一个函数，函数参数为传入属性的属性值
  from(list).pipe(
  	distinctUntilKeyChanged('name', (a, b) => {
  		return ...
  	})
  )
  ```

- **elementAt**

  只返回一个值，这个值位于发送的序列的指定位置

  ```
  from(list).pipe(
  	elementAt(2)
  )
  ```

- **first/last**

  只返回第一个或是过滤后的第一个值或最后一个

  ```
  from(list).pipe(
  	first()
  )
  from(list).pipe(
  	last()
  )
  ```

- **auditTime/audit**

  节流，但是只能输出时间内的最后一个值。

  ```
  fromEvent<MouseEvent>(document, 'mousemove')
  .pipe(
  	auditTime(500)
  )
  .subscribe((event) => console.log(event.x));
  
  fromEvent<MouseEvent>(document, 'mousemove')
  .pipe(
  	// audit(() => interval(500))
  	audit(() => timer(500))
  )
  .subscribe((event) => console.log(event.x));
  ```

- **sampleTime/sample**

  与`auditTime`很相似，差别在于`sampleTime`是每隔一段时间就获取一次值，它是一直在运作的，即使在这个时间段内没有值也会去获取。而`auditTime`是获取事件发生指定时间后的最近的一次事件发出的值。只有触发事件才会执行`auditTime`

  ```
  const source = new Subject();
  source.pipe(
    sampleTime(1500)
  ).subscribe(data => {
    console.log(`sampleTime 示例: ${data}`);
  });
  
  setTimeout(() => source.next(1), 0);
  setTimeout(() => source.next(2), 500);
  setTimeout(() => source.next(3), 1000);
  setTimeout(() => source.next(4), 4000);
  setTimeout(() => source.next(5), 5000);
  setTimeout(() => source.complete(), 5500);
  // 3, 4
  1--2--3------------4----5--|
  sampleTime(1500)
  ---------3------------4----|
  		1500   3000(没有值)
  					4500
  							5000
  							
  source.pipe(
    sample(interval(1500))
  ).subscribe(data => {
    console.log(`sampleTime 示例: ${data}`);
  });
  setTimeout(() => source.next(1), 0);
  setTimeout(() => source.next(2), 500);
  setTimeout(() => source.next(3), 1000);
  setTimeout(() => source.next(4), 4000);
  setTimeout(() => source.next(5), 5000);
  setTimeout(() => source.complete(), 5500);
  ```

- **skip/skipLast**

  跳过数据的前几项(skip)或后几项(skipLast)

  ```
  from(new Array(10).fill(10))
  .pipe(
  	map((val, index) => val + index),
  	skip(5)
  )  =>  15,13,17,18,19
  from(new Array(10).fill(10))
  .pipe(
  	map((val, index) => val + index),
  	skipLast(5)
  )  =>  10,11,12,13,14
  ```

- **skipUntil**

  接受一个`Observable`，返回一个`Observable`，忽略源`Observable`发出的数据，直到`skipUntil`传入的`Observable`返回值，才开始接收源`Observable`发出的剩下的值。

  ```
  interval(1000)
  .pipe(
  	skipUntil(timer(5000))
  )  =>  5秒后从4开始接收数据
  interval(1000)
  .pipe(
  	skipUntil(fromEvent(btn, 'click'))
  )  => 点击按钮后才接收interval的数据
  ```

- **skipWhile**

  传入一个函数，当函数返回false时，该`Observable`开始发出由源`Observable`发出的项。

  ```
  from([0,1,2,3,4,5,4,3,2,1,0])
  .pipe(
  	skipWhile(val => val < 4)
  )  => [4,5,4,3,2,1,0]
  ```

- **take/takeLast**

  接收源`Observable`开始(take)或后面(takeLast)的几项。

- **takeUntil**

  与`skipUntil`相反，在开始时发出源`Observable`的每一项，当`takeUntil`传入的`Observable`返回值时，停止接收源`Observable`发出的值。

- **takeWhile**

  与`skipWhile`相反，在开始时发出源`Observable`的每一项，直到传入的函数返回`false`时停止接收。

- **throttle/throttleTime**

  在内部定时器关闭时返回源`Observable`的值，返回后重新开启定时器。开始时定时器时关闭的。

  ```
  fromEvent<MouseEvent>(document, 'mousemove')
  .pipe(throttle(() => interval(1000)))
  .subscribe((event) => console.log(event.x));
  
  fromEvent<MouseEvent>(document, 'mousemove')
  .pipe(throttleTime(1000))
  .subscribe((event) => console.log(event.x));
  ```

#### 转换操作符

- **buffer**

  传入一个`Observable`。收集源`Observable`发出的每一项，当传入的`Observable`返回值时以数组形式发出收集的源`Observable`发出的每一项，没收集到时发出一个空数组。

  ```
  interval(1000)
  .pipe(
  	buffer(fromEvent(btn, 'click'))
  ).subscribe(val => console.log(val))
  interval(1000)
  .pipe(
  	buffer(interval(5000))
  )
  .subscribe((val) => console.log(val));
  ```

- **bufferCount**

  收集源`Observable`的值，达到一定数量时发出。

  ```
  from(new Array(10).fill(10))
  .pipe(
      map((val, index) => val + index),
      bufferCount(3)
  )
  ```

  ![img](https://cn.rx.js.org/img/bufferCount.png)

- 